withenv @empty_map;
block (@print)"wow!";
defer (@print)"leaving.";
defsymbol #demo;
withenv (@mapset)[env #demo "hello, world!"];
block (@print)(@mapget)[env #demo];
//block (@compileLog)(@typeOf)env;
@void

// defsymbol #platform;
// block (@mapset)[env, #platform, import "platform"];
// block ((@mapget)[(@mapget)[env #platform], "print"])"hello, world!";
// void

// block env.#platform = import "platform";
// block (env.#platform."print")"hello, world!";

// block (env.#std."if")[env.#condition, |_| "true", |_| "false"]
// |_| is zig 'stack-capturing macros'
// basically it's a function that must be called immediately
// and it can break control flow and stuff

// oh here's a little minor issue with that
// a = 2; (some_fn)[1, |_| a, a = 3];
// is that an issue?
// the idea is supposed to be that it's evaluated instantly
// like it has to be evaluated somewhere but is that ok?
// can some_fn return it? what are the like when can it be evaluated

// ok so using '.' introduces a place where I need ()
// like eg (env.#std)."if" vs env.(#std."if")
// and that means it can't be used for fn call
// unless I eg
// (@access)[env, #std, "if"]
// (@access)[env, (@access)[#std, "if"]]
// or uuh
// (..env #std "if") vs (.env.#std "if")

// (@typeof)@print :: (@fn_type)[string, void]
// oh we need to have some notes on fns
// eg: pure
// fns are pure by default and if you want to do something impure with
// them you have to tag them
// anyway in @fn_type there needs to be a way to specify those things
// eg is this fn pure or not
// pure fns are nice b/c they can be executed at compiletime
// oh pure fns can only call other pure fns too right

// a pure function:
// - has a readonly parameter
// - does not use any variables outside itself (can't view or modify)
// (note that an impure fn can be contained in a pure fn that accesses
//  variables outside itself, even variables in the pure fn)

// as call @fn_type array [string, void] @print
// @fn_type :: function. args: [type, type] -> fn(arg_type) return_type

// (typeof) @print :: (fn) string -> void
// (typeof) "wow" :: "wow"
// (typeof) @env :: (fn) void -> #magic
// for this reason, I think @env should not be a built in fn

// defsymbol #demo;
// block @print/"wow" defer @print/"leaving.";
// block @mapset/[@env/void #demo "hello, world!"]

// block /@print/ "wow" defer /@print/ "leaving";
// block /@mapset/ [/@env/ void #demo "hello, world!"]

// block (@print)"wow" defer (print)"leaving";
// block (@mapset)[(@env)void #demo "hello, world"]

//{(@print (@mapget [(@env void), #demo]))}
//
//block void void void
//
//array [void void void void]
