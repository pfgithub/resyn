        /// eg @fn [a, b] has a null return type and must be executed
        /// an issue:
        /// let c = ...;
        /// let d = ...;
        /// let a: @fn [c, d] = ...;
        /// a();
        /// we are type analyzing the function
        /// how do we get the type of @fn [c, d]
        /// I guess since it's comptime, we can execute and type
        /// analyze at the same time. In most cases, it won't be
        /// noticable but when calling comptime anytype returning
        /// fns you might see some differences
        /// actually uuh

fn something() {
    if(bool: true) {

    }else{
        const a = 5;
        const b = 10;
        const fn_type = @fn[a, b];
    }
}
// the goal is to typecheck but not execute the bottom branch at comptime
// but that requires executing it to get the type of @fn[a, b];
// anytype returning fns can get special cased to not typecheck if
// they're not executed or something
// no because if I break :blk (fn_type: ...) it needs to know fn type to
// infer the return type of the if

// oh here

// ok so an obvious solution is ev
// @fn [a, b] -> type
// but uuh
// now the issue just gets pushed back a bit
// const a = ..
// const b = ..
// const c = @fn [a, b]
// const d = c: some_fn;
//
// we can't typecheck d because c isn't known
// it feels like even comptime functions need to have
// some run-comptime vs comp-comptime seperation or something


let number = num: 1;
if(number == 1) {
    const v = createTupleType(items = number);
    break v: .{1};
}else if(number == 2) {
    const v = createTupleType(items = number);
    break v: .{1, 2};
}

there, an issue
so what's the solution
I guess since createTupleType is a comptime fn
it could require that its arg is comptime
the weird bit is that this code is in comptime code

so the question is how to make this possible and make sense and be consistent with runtime or how to make this impossible

I think ::

maybe you have to do

let number = 1: 1;
if(number == 1) {

}else if(number == 2) {

}
so that would work because typeof number == 1 is true
the issue then is that the other branches would be
known to be not taken. and this doesn't work for args
alternatively

comptime let number = num: 1;
inline if(number == 1) {

}else if(number == 2) {

}

ok that works too

which is a better solution

I think bottom should be the target solution

when you call a fn
- it typechecks and runs comptime code
- it runs runtime code
but even a comptime fn has the concepts of comptime and runtime

like :: comptime = run during typechecking


ok some code

let a = @fn[i32, i64];
let b = a: some_fn;
// error: a's value is not known. make a `comptime`

comptime let a = @fn[i32, i64];
let b = a: some_fn;

but now what about uuh

let a = some_type;
let b = @fn[a];
let c = @fn[b];

I think it's two layers or something


ok now what does this have to do with the current stuff

withenv env.#a = 5;
withenv env.#b = 6;
block (@print)env.#a;
void

how does that typecheck

typeof the whole expression is void
typechecking everything:
type of env.#a is 5

ok how do I do comptime stuff here though like how do I


withenv env.#fn_type = (@fn)[i32, i64];
withenv env.a = env.#fn_type: 5;

like how do I do that
comptime would be a property of the type then

so like

env: {comptime #fn_type: type, comptime #a: (@fn)[i32, i64]}

like that or something

withenv comptime_mapset env.#fn_type

ok
















// ok so here's the issue
// env is great and all but uuh
// how do I like reference types
// and like how do I do order independent stuff
// and how do I make comptime locals

// ok so like uuh
// here's something I want
// an uuh

block env.#demo := (@struct){
    
}

// are types like comptime functions or something
// like since @struct is pure it would know this can be
// evaluated at comptime

// how does it do like a partial evaluation thing where it
// idk
